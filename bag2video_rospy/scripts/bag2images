#!/usr/bin/env python3

from __future__ import division
import rosbag
import rospy
import numpy as np
import sys
import imageio
import logging
import traceback
from cv_bridge import CvBridge

import bag2video_common


def get_sizes(
    bag,
    topics=None,
    index=0,
    scale=1.0,
    start_time=rospy.Time(0),
    stop_time=rospy.Time(sys.maxsize),
):
    logging.debug("Resizing height to topic %s (index %d)." % (topics[index], index))
    sizes = []

    for topic in topics:
        try:
            iterator = bag.read_messages(
                topics=topic, start_time=start_time, end_time=stop_time
            )  # , raw=True)
            msg = next(iterator)[1]  # read one message
            sizes.append((msg.width, msg.height))
        except Exception:
            logging.critical(
                f"No messages found for topic {topic}, or message does not have height/width."
            )
            traceback.print_exc()
            sys.exit(1)

    target_height = int(sizes[index][1] * scale)

    # output original and scaled sizes
    for i in range(len(topics)):
        logging.info(f"Topic {topics[i]} originally {sizes[i][0]} x {sizes[i][1]}")
        image_height = sizes[i][1]
        image_width = sizes[i][0]

        # rescale to desired height while keeping aspect ratio
        sizes[i] = (
            int(1.0 * image_width * target_height / image_height),
            target_height,
        )
        logging.info(f"Topic {topics[i]} rescaled to {sizes[i][0]} x {sizes[i][1]}")

    return sizes


def write_frames(
    bag,
    outdir,
    topics,
    sizes,
    start_time=rospy.Time(0),
    stop_time=rospy.Time(sys.maxsize),
    viz=False,
    encoding="bgr8",
    skip=1,
):
    bridge = CvBridge()
    convert = {topics[i]: i for i in range(len(topics))}

    images = [
        np.zeros((sizes[i][1], sizes[i][0], 3), np.uint8) for i in range(len(topics))
    ]
    count = 0

    iterator = bag.read_messages(
        topics=topics, start_time=start_time, end_time=stop_time
    )

    topic, msg, t = next(iterator)
    image = np.asarray(bridge.imgmsg_to_cv2(msg, encoding))
    images[convert[topic]] = image

    for topic, msg, t in iterator:
        time = t.to_sec()

        logging.debug(f"Topic {topic} updated at time {time} seconds")

        if count % skip == 0:
            # record the current information up to this point in time
            logging.info(f"Writing image {count} at ROS time {time:.6f} seconds.")
            merged_image = bag2video_common.merge_images(images, sizes)

            outpath = outdir / ("image_%06d.png" % count)
            logging.debug("Writing %s" % outpath)
            imageio.imwrite(outpath, merged_image)

        count += 1

        image = np.asarray(bridge.imgmsg_to_cv2(msg, encoding))
        images[convert[topic]] = image

    merged_image = bag2video_common.merge_images(images, sizes)

    outpath = outdir / ("image_%06d.png" % count)
    logging.debug("Writing %s" % outpath)
    imageio.imwrite(outpath, merged_image)


if __name__ == "__main__":
    args = bag2video_common.images_argparser()

    args.outdir.mkdir(exist_ok=True)

    # convert numbers into rospy Time
    start_time = rospy.Time(args.start)
    stop_time = rospy.Time(args.end)

    for bagfile in args.bagfiles:
        logging.info(f"Proccessing bag {bagfile}")
        bag = rosbag.Bag(bagfile, "r")

        logging.info("Calculating video sizes.")
        sizes = get_sizes(
            bag,
            topics=args.topic,
            index=args.index,
            scale=args.scale,
            start_time=start_time,
            stop_time=stop_time,
        )

        logging.info("Calculating final image size.")
        out_width, out_height = bag2video_common.calc_out_size(sizes)
        logging.info(f"Images will be {out_width} x {out_height}")

        write_frames(
            bag=bag,
            outdir=args.outdir,
            topics=args.topic,
            sizes=sizes,
            start_time=start_time,
            stop_time=stop_time,
            encoding=args.encoding,
            skip=args.skip,
        )

        logging.info("Done.")
