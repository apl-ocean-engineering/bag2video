#!/usr/bin/env python3

from __future__ import division
import rosbag
import rospy
import numpy as np
import sys
import os
import cv2
from timeit import default_timer as timer
from datetime import datetime
import imageio
import logging
import traceback
from cv_bridge import CvBridge

import bag2video_common


def get_sizes(
    bag,
    topics=None,
    index=0,
    scale=1.0,
    start_time=rospy.Time(0),
    stop_time=rospy.Time(sys.maxsize),
):
    logging.debug(f"Resizing height to topic {topics[index]} (index {index}).")
    sizes = []

    for topic in topics:
        try:
            iterator = bag.read_messages(
                topics=topic, start_time=start_time, end_time=stop_time
            )  # , raw=True)
            msg = next(iterator)[1]  # read one message
            sizes.append((msg.width, msg.height))
        except Exception:  # \todo{} Should use a more specific exception
            logging.critical(
                f"No messages found for topic {topic}, or message does not have height/width."
            )
            traceback.print_exc()
            sys.exit(1)

    target_height = int(sizes[index][1] * scale)

    # output original and scaled sizes
    for i in range(len(topics)):
        logging.info(f"Topic {topics[i]} originally {sizes[i][0]} x {sizes[i][1]}")
        image_height = sizes[i][1]
        image_width = sizes[i][0]

        # rescale to desired height while keeping aspect ratio
        sizes[i] = (
            int(1.0 * image_width * target_height / image_height),
            target_height,
        )
        logging.info(f"Topic {topics[i]} rescaled to {sizes[i][0]} x {sizes[i][1]}")

    return sizes


def get_frequency(
    bag, topics=None, start_time=rospy.Time(0), stop_time=rospy.Time(sys.maxsize)
):
    info = bag.get_type_and_topic_info(topics)
    logging.debug(info)

    # uses the highest topic message frequency as framerate
    frequency = 0
    for topic in topics:
        topic_frequency = info[1][topic][
            3
        ]  # returns the reciprocal of the median difference in timestamps for the topic
        logging.info(f"Topic {topic} has a frequency of {topic_frequency}.")
        if topic_frequency is not None:
            frequency = max(frequency, topic_frequency)

    if frequency <= 0:
        logging.critical("Unable to calculate framerate from topic frequency.")
        logging.critical("May be caused by a lack of messages.")
        traceback.print_exc()
        sys.exit(1)

    return frequency


def write_frames(
    bag,
    writer,
    topics,
    sizes,
    fps,
    start_time=rospy.Time(0),
    stop_time=rospy.Time(sys.maxsize),
    viz=False,
    encoding="bgr8",
    timestamp=False,
):
    bridge = CvBridge()
    convert = {topics[i]: i for i in range(len(topics))}
    frame_duration = 1.0 / fps

    images = [
        np.zeros((sizes[i][1], sizes[i][0], 3), np.uint8) for i in range(len(topics))
    ]
    frame_num = 0

    iterator = bag.read_messages(
        topics=topics, start_time=start_time, end_time=stop_time
    )

    topic, msg, t = next(iterator)
    image = np.asarray(bridge.imgmsg_to_cv2(msg, encoding))
    images[convert[topic]] = image
    frame_num = int(t.to_sec() / frame_duration)

    start = timer()
    num_frames = 0
    num_msgs = 0

    for topic, msg, t in iterator:
        time = t.to_sec()

        frame_num_next = int(time / frame_duration)
        reps = frame_num_next - frame_num

        logging.debug(
            f"Topic {topic} updated at time {time} seconds, frame {frame_num_next}."
        )

        # prevent unnecessary calculations
        if reps > 0:
            # record the current information up to this point in time
            logging.info(
                f"Writing image {num_msgs} at ROS time {time:.6f} seconds, frame {frame_num} for {reps} frames."
            )
            merged_image = bag2video_common.merge_images(images, sizes)

            if timestamp:
                dt = datetime.fromtimestamp(time)
                merged_image = cv2.putText(
                    merged_image,
                    dt.isoformat(),
                    (0, 200),
                    cv2.FONT_HERSHEY_SIMPLEX,
                    4,
                    (255, 0, 0),
                    2,
                    cv2.LINE_AA,
                )

            for i in range(reps):
                # writer.write(merged_image) # opencv
                num_frames = num_frames + 1
                writer.append_data(merged_image)  # imageio

            num_msgs = num_msgs + 1

            imshow_f("win", merged_image)
            frame_num = frame_num_next

        image = np.asarray(bridge.imgmsg_to_cv2(msg, encoding))
        images[convert[topic]] = image

    end = timer()
    logging.info(
        f"Wrote {num_msgs} messages to {num_frames} frames in {end-start:.2f} seconds"
    )


def imshow(win, img):
    logging.debug("Window redrawn.")
    cv2.imshow(win, img)
    cv2.waitKey(1)


def noshow(win, img):
    pass


if __name__ == "__main__":
    args = bag2video_common.video_argparser()

    if args.imshow:
        imshow_f = imshow
    else:
        imshow_f = noshow

    # convert numbers into rospy Time
    start_time = rospy.Time(args.start)
    stop_time = rospy.Time(args.end)

    writer = None

    for bagfile in args.bagfiles:
        logging.info(f"Proccessing bag {bagfile}")
        outfile = args.outfile
        if outfile is None:
            folder, name = os.path.split(bagfile)
            outfile = os.path.join(folder, name[: name.rfind(".")]) + ".mp4"
        bag = rosbag.Bag(bagfile, "r")

        fps = args.fps
        if not fps:
            logging.info("Calculating ideal output framerate.")
            fps = get_frequency(bag, args.topic, start_time, stop_time)
            logging.info(f"Output framerate of {fps:.3f}.")
        else:
            logging.info(f"Using manually set framerate of {fps:.3f}")

        logging.info("Calculating video sizes.")
        sizes = get_sizes(
            bag,
            topics=args.topic,
            index=args.index,
            scale=args.scale,
            start_time=start_time,
            stop_time=stop_time,
        )

        logging.info("Calculating final image size.")
        out_width, out_height = bag2video_common.calc_out_size(sizes)
        logging.info(f"Resulting video size {out_width} x {out_height}")

        logging.info("Opening video writer.")
        # fourcc = cv2.VideoWriter_fourcc(*args.fourcc) # opencv
        # writer = cv2.VideoWriter(outfile, fourcc, fps, (out_width,out_height)) # opencv

        if not writer:
            writer = imageio.get_writer(
                outfile,
                format="FFMPEG",
                mode="I",
                fps=fps,
                quality=10,
                codec=args.codec,
            )
        # writer = imageio.get_writer(outfile, fps=fps, mode='I', format="FFMPEG", macro_block_size=1) # imageio

        logging.info(f"Writing video at {outfile}")
        write_frames(
            bag=bag,
            writer=writer,
            topics=args.topic,
            sizes=sizes,
            fps=fps,
            start_time=start_time,
            stop_time=stop_time,
            encoding=args.encoding,
            timestamp=args.timestamp,
        )
        # writer.release() # opencv

    writer.close()  # imageio

    logging.info("Done.")
